"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeResolver = void 0;
class Resolver {
    functions;
    constructor() {
        this.functions = {};
    }
    define(functionKey, cb) {
        if (!cb || typeof cb !== 'function') {
            throw new Error(`Resolver definition '${functionKey}' callback must be a 'function'. Received '${typeof cb}'.`);
        }
        if (functionKey in this.functions) {
            throw new Error(`Resolver definition '${functionKey}' already exists.`);
        }
        this.functions[functionKey] = cb;
        return this;
    }
    getFunction(functionKey) {
        if (functionKey in this.functions) {
            return this.functions[functionKey];
        }
        throw new Error(`Resolver has no definition for '${functionKey}'.`);
    }
    sanitizeObject(object) {
        return JSON.parse(JSON.stringify(object));
    }
    getDefinitions() {
        return async ({ call: { functionKey, payload, jobId }, context }, backendRuntimePayload) => {
            const cb = this.getFunction(functionKey);
            const result = await cb({
                payload: payload || {},
                context: {
                    ...context,
                    installContext: backendRuntimePayload?.installContext,
                    accountId: backendRuntimePayload?.principal?.accountId,
                    license: backendRuntimePayload?.license,
                    jobId: jobId,
                    installation: backendRuntimePayload?.installation
                }
            });
            if (typeof result === 'object') {
                return this.sanitizeObject(result);
            }
            return result;
        };
    }
}
exports.default = Resolver;
function makeResolver(handlers) {
    const resolver = new Resolver();
    for (const key of Object.keys(handlers)) {
        resolver.define(key, handlers[key]);
    }
    return resolver.getDefinitions();
}
exports.makeResolver = makeResolver;
