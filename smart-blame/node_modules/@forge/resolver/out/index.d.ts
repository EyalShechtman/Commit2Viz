import type { Context, DefArgument, DefResult, Definitions, Request } from './shared';
export { Request };
declare type InvokePayload<Argument> = {
    call: {
        functionKey: string;
        payload?: Argument;
        jobId?: string;
    };
    context: Context;
};
export declare type Response = {
    [key: string]: any;
} | string | void;
export declare type ResolverFunction<Argument = any, Result = Response> = (request: Request<Argument>) => Promise<Result> | Result;
declare type DefinitionsHandler = (payload: InvokePayload<unknown>, backendRuntimePayload?: Record<string, any>) => Promise<unknown>;
export default class Resolver {
    private functions;
    constructor();
    define(functionKey: string, cb: ResolverFunction<never, unknown>): this;
    private getFunction;
    private sanitizeObject;
    getDefinitions(): DefinitionsHandler;
}
export declare type Handlers<D extends Definitions> = {
    [Def in keyof D & string]: ResolverFunction<DefArgument<D, Def>, DefResult<D, Def>>;
};
export declare function makeResolver<D extends Definitions>(handlers: Handlers<D>): DefinitionsHandler;
//# sourceMappingURL=index.d.ts.map