"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.usePermissions = void 0;
const react_1 = require("react");
const bridge_1 = require("@forge/bridge");
const minimatch_1 = require("minimatch");
/**
 * https://ecosystem-platform.atlassian.net/browse/DEPLOY-1411
 * reuse logic from @forge/api
 */
/**
 * Resource types that can be loaded externally
 */
const RESOURCE_TYPES = ['fonts', 'styles', 'frames', 'images', 'media', 'scripts'];
/**
 * Fetch types for external requests
 */
const FETCH_TYPES = ['backend', 'client'];
/**
 * Helper function to check if a URL matches any of the allowed patterns
 * Uses minimatch for robust pattern matching with wildcards
 */
const matchesAllowedUrl = (url, allowedUrls) => {
    return allowedUrls.some((allowedUrl) => {
        // Use minimatch for pattern matching
        return (0, minimatch_1.minimatch)(url, allowedUrl);
    });
};
/**
 * Hook for checking permissions in Forge apps
 *
 * @param requiredPermissions - The permissions required for the component
 * @returns Object containing permission state, loading status, and error information
 * @returns hasPermission - Whether all required permissions are granted
 * @returns isLoading - Whether the permission check is still in progress
 * @returns missingPermissions - Details about which permissions are missing (null if all granted)
 * @returns error - Any error that occurred during permission checking (null if no error)
 *
 * @example
 * ```tsx
 * const MyComponent: React.FC = () => {
 *   const { hasPermission, isLoading, missingPermissions, error } = usePermissions({
 *     scopes: ['write:confluence-content'],
 *     external: {
 *       fetch: {
 *         backend: ['https://api.example.com']
 *       }
 *     }
 *   });
 *
 *   if (isLoading) return <LoadingSpinner />;
 *
 *   if (error) {
 *     return <ErrorMessage error={error} />;
 *   }
 *
 *   if (!hasPermission) {
 *     return <PermissionDenied missingPermissions={missingPermissions} />;
 *   }
 *
 *   return <ProtectedFeature />;
 * };
 * ```
 */
const usePermissions = (requiredPermissions) => {
    const [context, setContext] = (0, react_1.useState)();
    const [isLoading, setIsLoading] = (0, react_1.useState)(true);
    const [error, setError] = (0, react_1.useState)(null);
    // Load context on mount
    (0, react_1.useEffect)(() => {
        const loadContext = async () => {
            try {
                setIsLoading(true);
                setError(null);
                const contextData = await bridge_1.view.getContext();
                setContext(contextData);
            }
            catch (err) {
                setError(err instanceof Error ? err : new Error('Failed to load context'));
            }
            finally {
                setIsLoading(false);
            }
        };
        void loadContext();
    }, []);
    // Permission checking utilities
    const permissionUtils = (0, react_1.useMemo)(() => {
        if (!context?.permissions)
            return null;
        const { scopes, external = {} } = context.permissions;
        const scopeArray = Array.isArray(scopes) ? scopes : Object.keys(scopes || {});
        return {
            hasScope: (scope) => scopeArray.includes(scope),
            canFetchFrom: (type, url) => {
                const fetchUrls = external.fetch?.[type];
                if (!fetchUrls?.length)
                    return false;
                // Extract string URLs from fetch URLs array
                const allowedUrls = fetchUrls
                    .map((item) => {
                    // If item is already a string, use it directly
                    if (typeof item === 'string') {
                        return item;
                    }
                    // If item has an address property, use that
                    if ('address' in item && item.address) {
                        return item.address;
                    }
                    // Otherwise, use the remote property (if it exists)
                    return item.remote;
                })
                    .filter((url) => typeof url === 'string');
                return matchesAllowedUrl(url, allowedUrls);
            },
            canLoadResource: (type, url) => {
                const resourceUrls = external[type];
                if (!resourceUrls?.length)
                    return false;
                const stringUrls = resourceUrls.filter((item) => typeof item === 'string');
                return matchesAllowedUrl(url, stringUrls);
            },
            getScopes: () => scopeArray,
            getExternalPermissions: () => external,
            hasAnyPermissions: () => scopeArray.length > 0 || Object.keys(external).length > 0
        };
    }, [context?.permissions]);
    // Check permissions
    const permissionResult = (0, react_1.useMemo)(() => {
        if (!requiredPermissions) {
            return { granted: false, missing: null };
        }
        if (!permissionUtils) {
            // If still loading or there's an error, return null for missing permissions
            if (isLoading || error) {
                return { granted: false, missing: null };
            }
            throw new Error('This feature is not available yet');
        }
        const missing = {};
        let hasAllRequiredPermissions = true;
        // Check scopes
        if (requiredPermissions.scopes?.length) {
            const missingScopes = requiredPermissions.scopes.filter((scope) => !permissionUtils.hasScope(scope));
            if (missingScopes.length > 0) {
                missing.scopes = missingScopes;
                hasAllRequiredPermissions = false;
            }
        }
        // Check external permissions
        if (requiredPermissions.external) {
            const missingExternal = {};
            // Check fetch permissions
            if (requiredPermissions.external.fetch) {
                const missingFetch = {};
                FETCH_TYPES.forEach((type) => {
                    const requiredUrls = requiredPermissions.external?.fetch?.[type];
                    if (requiredUrls?.length) {
                        const missingUrls = requiredUrls.filter((url) => !permissionUtils.canFetchFrom(type, url));
                        if (missingUrls.length > 0) {
                            missingFetch[type] = missingUrls;
                            hasAllRequiredPermissions = false;
                        }
                    }
                });
                if (Object.keys(missingFetch).length > 0) {
                    missingExternal.fetch = missingFetch;
                }
            }
            // Check resource permissions
            RESOURCE_TYPES.forEach((type) => {
                const requiredUrls = requiredPermissions.external?.[type];
                if (requiredUrls?.length) {
                    const missingUrls = requiredUrls.filter((url) => !permissionUtils.canLoadResource(type, url));
                    if (missingUrls.length > 0) {
                        missingExternal[type] = missingUrls;
                        hasAllRequiredPermissions = false;
                    }
                }
            });
            if (Object.keys(missingExternal).length > 0) {
                missing.external = missingExternal;
            }
        }
        // Note: Content permissions are not supported in the current RuntimePermissions type
        return {
            granted: hasAllRequiredPermissions,
            missing: hasAllRequiredPermissions ? null : missing
        };
    }, [permissionUtils, requiredPermissions]);
    return {
        hasPermission: permissionResult.granted,
        isLoading,
        missingPermissions: permissionResult.missing,
        error
    };
};
exports.usePermissions = usePermissions;
