"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const jsx_runtime_1 = require("react/jsx-runtime");
const listeners = new Map();
const simpleBridgeEvents = {
    on: (event, callback) => {
        if (!listeners.has(event)) {
            listeners.set(event, []);
        }
        listeners.get(event)?.push(callback);
    },
    emit: (event, data) => {
        if (listeners.has(event)) {
            listeners.get(event)?.forEach((callback) => callback(data));
        }
    },
    clearListeners: (event) => {
        listeners.delete(event);
    }
};
// defining mock function above import so it is initialised before jest.mock runs
const mockGetContext = jest.fn(async () => null);
const react_1 = tslib_1.__importStar(require("react"));
const reconcilerTestRenderer_1 = tslib_1.__importDefault(require("../../__test__/reconcilerTestRenderer"));
const useConfig_1 = require("../useConfig");
const testUtils_1 = require("../../__test__/testUtils");
jest.mock('@forge/bridge', () => ({
    view: {
        getContext: mockGetContext
    },
    events: simpleBridgeEvents
}));
const MOCK_CONFIG = {
    value: 1
};
const MOCK_CONTEXT_WITH_CONFIG = {
    extension: {
        config: MOCK_CONFIG
    }
};
const MOCK_CONTEXT_NO_CONFIG = {
    extension: {}
};
const configListener = jest.fn();
// react app fragment to be load useProductContext hook
const renderTest = async () => {
    const Test = () => {
        const config = (0, useConfig_1.useConfig)();
        (0, react_1.useEffect)(() => configListener(config), [config]);
        return (0, jsx_runtime_1.jsx)(react_1.default.Fragment, {});
    };
    const { update } = await reconcilerTestRenderer_1.default.create((0, jsx_runtime_1.jsx)(Test, {}));
    return {
        update: async () => {
            await update((0, jsx_runtime_1.jsx)(Test, {}));
        }
    };
};
describe('useConfig', () => {
    beforeAll(() => (0, testUtils_1.setupBridge)());
    beforeEach(() => simpleBridgeEvents.clearListeners('FORGE_CORE_MACRO_CONFIG_CHANGED'));
    afterEach(() => jest.clearAllMocks());
    it('correctly outputs a given config', async () => {
        mockGetContext.mockResolvedValue(MOCK_CONTEXT_WITH_CONFIG);
        await renderTest();
        expect(configListener).toHaveBeenCalledWith(expect.objectContaining(MOCK_CONFIG));
    });
    it('when there is no config, outputs undefined', async () => {
        mockGetContext.mockResolvedValue(MOCK_CONTEXT_NO_CONFIG);
        await renderTest();
        expect(configListener.mock.calls[0][0]).toEqual(undefined); // initial rendered value
        // no change to undef value after productContext call, do not re-render
        expect(configListener).not.toHaveBeenNthCalledWith(2, expect.anything);
    });
    it('when config is updated, outputs new config', async () => {
        mockGetContext.mockResolvedValue(MOCK_CONTEXT_WITH_CONFIG);
        await renderTest();
        expect(mockGetContext).toHaveBeenCalledTimes(1);
        const newConfig = { value: 2 };
        simpleBridgeEvents.emit('FORGE_CORE_MACRO_CONFIG_CHANGED', newConfig);
        expect(mockGetContext).toHaveBeenCalledTimes(2);
    });
});
