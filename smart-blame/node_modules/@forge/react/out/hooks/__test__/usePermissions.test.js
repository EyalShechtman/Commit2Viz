"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_hooks_1 = require("@testing-library/react-hooks");
const usePermissions_1 = require("../usePermissions");
const testUtils_1 = require("../../__test__/testUtils");
// Mock @forge/bridge
jest.mock('@forge/bridge', () => ({
    view: {
        getContext: jest.fn()
    }
}));
const mockGetContext = jest.fn();
describe('usePermissions', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        (0, testUtils_1.setupBridge)();
        // Set up the mock to use our mockGetContext function
        const { view } = require('@forge/bridge');
        view.getContext.mockImplementation(mockGetContext);
    });
    describe('Interface inheritance', () => {
        it('should allow PermissionRequirements to be used as Permissions', () => {
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            // This should compile without errors, demonstrating inheritance
            const permissions = requiredPermissions;
            expect(permissions.scopes).toEqual(['read:confluence-content']);
        });
        it('should allow MissingPermissions to be used as Permissions', () => {
            const missingPermissions = {
                scopes: ['write:jira-work']
            };
            // This should compile without errors, demonstrating inheritance
            const permissions = missingPermissions;
            expect(permissions.scopes).toEqual(['write:jira-work']);
        });
    });
    describe('Loading state', () => {
        it('should start with loading true', () => {
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            expect(result.current.isLoading).toBe(true);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toBe(null);
            expect(result.current.error).toBe(null);
        });
        it('should set loading to false after context loads', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
    });
    describe('Error handling', () => {
        it('should handle context loading errors', async () => {
            const error = new Error('Failed to load context');
            mockGetContext.mockRejectedValue(error);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toEqual(error);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should handle non-Error objects in catch block', async () => {
            mockGetContext.mockRejectedValue('String error');
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.error).toEqual(new Error('Failed to load context'));
        });
    });
    describe('Scope permissions', () => {
        it('should grant permission when all required scopes are present', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'write:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should deny permission when required scopes are missing', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:jira-work']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                scopes: ['write:jira-work']
            });
        });
        it('should handle scopes as object format', async () => {
            const mockContext = {
                permissions: {
                    scopes: {
                        'read:confluence-content': { allowImpersonation: false },
                        'write:confluence-content': { allowImpersonation: true }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content']
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should handle empty scopes array', async () => {
            const mockContext = {
                permissions: {
                    scopes: []
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: []
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
    describe('External permissions', () => {
        it('should grant permission for allowed fetch URLs', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.test.com'],
                            client: ['https://cdn.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com'],
                        client: ['https://cdn.example.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should deny permission for disallowed fetch URLs', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.unauthorized.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                external: {
                    fetch: {
                        backend: ['https://api.unauthorized.com']
                    }
                }
            });
        });
        it('should handle wildcard URL patterns', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: ['https://api.example.com/*', 'https://*.test.com/**']
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com/users', 'https://subdomain.test.com/api']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should handle resource permissions (fonts, images, etc.)', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fonts: ['https://fonts.googleapis.com'],
                        images: ['https://images.example.com'],
                        scripts: ['https://scripts.example.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fonts: ['https://fonts.googleapis.com'],
                    images: ['https://images.example.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
    describe('Complex permission scenarios', () => {
        it('should handle mixed permission types', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'write:confluence-content', 'read:jira-work'],
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.test.com'],
                            client: ['https://cdn.example.com', 'https://cdn.test.com']
                        },
                        images: ['https://images.example.com', 'https://images.test.com'],
                        fonts: ['https://fonts.googleapis.com', 'https://fonts.gstatic.com'],
                        scripts: ['https://scripts.example.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:confluence-content'],
                external: {
                    fetch: {
                        backend: ['https://api.example.com'],
                        client: ['https://cdn.example.com']
                    },
                    images: ['https://images.example.com'],
                    fonts: ['https://fonts.googleapis.com'],
                    scripts: ['https://scripts.example.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
        it('should identify missing permissions across different types', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content', 'read:jira-work'],
                    external: {
                        fetch: {
                            backend: ['https://api.example.com', 'https://api.authorized.com'],
                            client: ['https://cdn.authorized.com']
                        },
                        images: ['https://images.authorized.com'],
                        fonts: ['https://fonts.authorized.com']
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                scopes: ['read:confluence-content', 'write:jira-work', 'admin:confluence'],
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.unauthorized.com', 'https://api.missing.com'],
                        client: ['https://cdn.example.com', 'https://cdn.unauthorized.com']
                    },
                    images: ['https://images.example.com', 'https://images.unauthorized.com'],
                    fonts: ['https://fonts.example.com'],
                    scripts: ['https://scripts.example.com', 'https://scripts.unauthorized.com']
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(false);
            expect(result.current.missingPermissions).toEqual({
                scopes: ['write:jira-work', 'admin:confluence'],
                external: {
                    fetch: {
                        backend: ['https://api.unauthorized.com', 'https://api.missing.com'],
                        client: ['https://cdn.example.com', 'https://cdn.unauthorized.com']
                    },
                    images: ['https://images.example.com', 'https://images.unauthorized.com'],
                    fonts: ['https://fonts.example.com'],
                    scripts: ['https://scripts.example.com', 'https://scripts.unauthorized.com']
                }
            });
        });
    });
    describe('Edge cases', () => {
        it('should handle empty required permissions', async () => {
            const mockContext = {
                permissions: {
                    scopes: ['read:confluence-content']
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {};
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
            expect(result.current.missingPermissions).toBe(null);
        });
        it('should handle complex external permission objects', async () => {
            const mockContext = {
                permissions: {
                    external: {
                        fetch: {
                            backend: [
                                'https://api.example.com',
                                { address: 'https://api.address.com' },
                                { remote: 'https://api.remote.com' }
                            ]
                        }
                    }
                }
            };
            mockGetContext.mockResolvedValue(mockContext);
            const requiredPermissions = {
                external: {
                    fetch: {
                        backend: ['https://api.example.com', 'https://api.address.com']
                    }
                }
            };
            const { result } = (0, react_hooks_1.renderHook)(() => (0, usePermissions_1.usePermissions)(requiredPermissions));
            await (0, react_hooks_1.act)(async () => {
                await new Promise((resolve) => setTimeout(resolve, 10));
            });
            expect(result.current.isLoading).toBe(false);
            expect(result.current.hasPermission).toBe(true);
        });
    });
});
